name: Deploy Backend to EC2

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'  

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Configure SSH
      env:
        SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_KEY }}
      run: |
        mkdir -p ~/.ssh
        # Store the PEM key with proper formatting
        echo "$SSH_PRIVATE_KEY" > ~/.ssh/ec2-key.pem
        chmod 600 ~/.ssh/ec2-key.pem
        # Disable strict host key checking for deployment
        echo "Host *
          StrictHostKeyChecking no
          UserKnownHostsFile=/dev/null" > ~/.ssh/config
          
    - name: Get remote home directory
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      id: get_home
      run: |
        REMOTE_HOME=$(ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST 'echo $HOME')
        echo "REMOTE_HOME=$REMOTE_HOME" >> $GITHUB_ENV
        echo "Remote home directory: $REMOTE_HOME"

    - name: Create docker-compose.yml
      run: |
        echo 'version: "3"' > docker-compose.yml
        echo '' >> docker-compose.yml
        echo 'services:' >> docker-compose.yml
        echo '  backend:' >> docker-compose.yml
        echo '    build: .' >> docker-compose.yml
        echo '    restart: always' >> docker-compose.yml
        echo '    ports:' >> docker-compose.yml
        echo '      - "8000:8000"' >> docker-compose.yml
        echo '    env_file:' >> docker-compose.yml
        echo '      - .env' >> docker-compose.yml
        echo '    volumes:' >> docker-compose.yml
        echo '      - ./backend:/app/backend' >> docker-compose.yml
        echo '      - ./certs:/app/certs' >> docker-compose.yml
        echo '    command: ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--ssl-keyfile", "/app/certs/key.pem", "--ssl-certfile", "/app/certs/cert.pem"]' >> docker-compose.yml

    - name: Create Dockerfile
      run: |
        echo 'FROM python:3.13-slim' > Dockerfile
        echo '' >> Dockerfile
        echo 'WORKDIR /app' >> Dockerfile
        echo '' >> Dockerfile
        echo '# Install build tools and Cairo dev libraries needed for PyCairo' >> Dockerfile
        echo 'RUN apt-get update && apt-get install -y --no-install-recommends build-essential gcc libcairo2-dev pkg-config && rm -rf /var/lib/apt/lists/*' >> Dockerfile
        echo '' >> Dockerfile
        echo 'COPY backend/requirements.txt .' >> Dockerfile
        echo '# Debug: List files and show requirements.txt content' >> Dockerfile
        echo 'RUN ls -la /app' >> Dockerfile
        echo 'RUN cat /app/requirements.txt' >> Dockerfile
        echo '# Update pip before installing requirements' >> Dockerfile
        echo 'RUN python -m pip install --upgrade pip' >> Dockerfile
        echo 'RUN pip install --no-cache-dir -r requirements.txt' >> Dockerfile
        echo '' >> Dockerfile
        echo 'COPY backend /app/backend' >> Dockerfile
        echo '' >> Dockerfile
        echo 'WORKDIR /app/backend' >> Dockerfile
        echo '' >> Dockerfile
        echo 'CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]' >> Dockerfile

    - name: Copy files to EC2 using rsync
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      run: |
        # Create the main app directory
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "mkdir -p $REMOTE_HOME/app"
        
        # Sync backend directory, excluding __pycache__
        echo "Syncing backend directory..."
        rsync -avz --delete --exclude='__pycache__' -e "ssh -i ~/.ssh/ec2-key.pem" ./backend/ $EC2_USERNAME@$EC2_HOST:$REMOTE_HOME/app/backend/
        
        # Sync docker-compose.yml
        echo "Syncing docker-compose.yml..."
        rsync -avz -e "ssh -i ~/.ssh/ec2-key.pem" ./docker-compose.yml $EC2_USERNAME@$EC2_HOST:$REMOTE_HOME/app/
        
        # Sync Dockerfile
        echo "Syncing Dockerfile..."
        rsync -avz -e "ssh -i ~/.ssh/ec2-key.pem" ./Dockerfile $EC2_USERNAME@$EC2_HOST:$REMOTE_HOME/app/

    - name: Install Docker and Docker Compose
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      run: |
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "
          set -e # Exit immediately if a command exits with a non-zero status.
          # Check if jq is installed, install if not
          if ! command -v jq &> /dev/null; then
            echo 'jq not found, installing...'
            sudo apt-get update && sudo apt-get install -y jq
          fi
          
          # Install Docker if not already installed
          if ! command -v docker &> /dev/null; then
            echo 'Installing Docker...'
            sudo apt-get update
            sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common
            curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -
            sudo add-apt-repository -y 'deb [arch=amd64] https://download.docker.com/linux/debian buster stable' # Assuming Debian Buster, adjust if needed
            sudo apt-get update
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io
            sudo systemctl start docker
            sudo systemctl enable docker
            sudo usermod -aG docker \$USER # Correctly escape $USER for remote execution
            echo 'Docker installation completed. You might need to re-login for group changes to apply.'
          else
            echo 'Docker is already installed'
          fi
          
          # Install Docker Compose v2
          if ! docker compose version &> /dev/null; then # Check using 'docker compose' command
            echo 'Installing Docker Compose v2 (as plugin)...'
            # Use jq to safely get the latest version tag
            LATEST_COMPOSE_VERSION=\$(curl -s https://api.github.com/repos/docker/compose/releases/latest | jq -r .tag_name)
            echo "Latest Docker Compose version: \$LATEST_COMPOSE_VERSION"
            DOCKER_CONFIG=${DOCKER_CONFIG:-\$HOME/.docker}
            sudo mkdir -p \$DOCKER_CONFIG/cli-plugins
            sudo curl -SL "https://github.com/docker/compose/releases/download/\$LATEST_COMPOSE_VERSION/docker-compose-linux-x86_64" -o \$DOCKER_CONFIG/cli-plugins/docker-compose
            sudo chmod +x \$DOCKER_CONFIG/cli-plugins/docker-compose
            # Verify installation
            docker compose version
            echo 'Docker Compose installation completed'
          else
            echo 'Docker Compose v2 plugin is already installed'
          fi
        "

    - name: Generate SSL certificates
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      run: |
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "
          cd $REMOTE_HOME/app &&
          mkdir -p certs &&
          cd certs &&
          openssl req -x509 -newkey rsa:4096 -nodes -out cert.pem -keyout key.pem -days 365 -subj '/CN=localhost'
        "

    - name: Deploy with Docker Compose
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
        DB_URL: ${{ secrets.DB_URL }}
        SECRET_KEY: ${{ secrets.SECRET_KEY }}
        POSTMARK_TOKEN: ${{ secrets.POSTMARK_TOKEN }}
        FRONTEND_BASE_URL: ${{ secrets.FRONTEND_BASE_URL }}
        ENVIRONMENT: "production"
      run: |
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "
          cd $REMOTE_HOME/app && 
          echo \"DB_URL=$DB_URL\" > .env &&
          echo \"SECRET_KEY=$SECRET_KEY\" >> .env &&
          echo \"POSTMARK_TOKEN=$POSTMARK_TOKEN\" >> .env &&
          echo \"FRONTEND_BASE_URL=$FRONTEND_BASE_URL\" >> .env &&
          echo \"ENV=$ENVIRONMENT\" >> .env &&
          echo \"CORS_ORIGINS=https://www.hpgrind.se\" >> .env &&
          
          # Modify docker-compose to use restart-on-failure instead of always restarting
          if grep -q 'restart: always' docker-compose.yml; then
            sed -i 's/restart: always/restart: on-failure:5/' docker-compose.yml
            echo 'Modified restart policy to prevent infinite restart loops'
          fi
          
          # Use Docker Compose v2 command
          docker compose down || echo 'No existing containers to stop'
          docker compose up -d --build
          
          # Wait for container to stabilize
          echo 'Waiting for container to stabilize...'
          sleep 30
          
          # Check if container is running or in a restart loop
          CONTAINER_STATUS=\$(docker ps -a --filter name=backend --format '{{.Status}}')
          if [[ \$CONTAINER_STATUS == *\"Restarting\"* ]]; then
            echo 'Container is in a restart loop. Checking logs:'
            docker logs \$(docker ps -aq --filter name=backend)
          else
            echo 'Container appears to be stable. Status: '\$CONTAINER_STATUS
          fi
        "

    - name: Check Container Logs
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      run: |
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "
          cd $REMOTE_HOME/app &&
          echo 'Checking container logs to identify restart issue...'
          docker logs \$(docker ps -aq --filter name=backend) || echo 'Could not get container logs'
          
          echo 'Checking container status...'
          docker ps -a
          
          echo 'Checking Docker events...'
          docker events --since 5m --until 0m --filter container=\$(docker ps -aq --filter name=backend) || echo 'No recent events'
        "

    - name: Verify Database Settings
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      run: |
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "
          cd $REMOTE_HOME/app && 
          # Wait for the backend service to start up
          echo 'Waiting for the backend service to start up...'
          sleep 15
          
          # Run database diagnostics for detailed troubleshooting
          echo 'Running database diagnostics...'
          docker compose exec -T backend python -m db_diagnostic || echo 'Database diagnostics failed. Proceeding with verification...'
          
          # Verify database settings
          echo 'Verifying database settings...'
          docker compose exec -T backend python -m verify_db_settings || {
            # If verification fails, print DB_URL for debugging (without password)
            echo 'Database settings verification failed. Checking environment variables...'
            docker compose exec -T backend bash -c 'echo \"DB_URL: \${DB_URL//:/\\:*@/:***@}\"'
            
            # Let's check if we need to add the IP to pg_hba.conf (common issue)
            echo 'Checking if this is a pg_hba.conf issue...'
            CONTAINER_IP=\$(docker compose exec -T backend hostname -i 2>/dev/null || echo 'unknown')
            echo \"Container IP address: \$CONTAINER_IP\"
            echo \"If you're seeing 'no pg_hba.conf entry' errors, make sure this IP is allowed to connect to your database\"
            echo \"You may need to add a line like this to pg_hba.conf on your PostgreSQL server:\"
            echo \"host    database    username    \$CONTAINER_IP/32    md5\"
            
            echo 'Please check your database connection settings in GitHub Secrets.'
          }
        "

    - name: Initialize Database
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      run: |
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "
          cd $REMOTE_HOME/app && 
          # Execute the database initialization script within the container
          echo 'Initializing database...'
          if ! docker compose exec -T backend python -m init_db; then
            echo 'First attempt failed, waiting longer and trying again...'
            sleep 15
            if ! docker compose exec -T backend python -m init_db; then
              echo 'Second attempt also failed. Trying to run initialization from inside the container directly...'
              docker compose exec -T backend bash -c 'cd /app/backend && python -m init_db'
            fi
          fi
          
          echo 'Database initialization completed.'
          
          # Verify database tables exist
          echo 'Verifying database initialization...'
          docker compose exec -T backend python -c 'from api.v1.core.models import User; from db_setup import get_db; db = next(get_db()); print(f\"User table exists with {db.query(User).count()} users\")' || {
            echo 'Database verification failed. Please check the logs above for errors.'
          }
        "

    - name: Fix Database Credentials (If Needed)
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      run: |
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "
          cd $REMOTE_HOME/app && 
          echo 'Creating a script to attempt database connection with alternate credentials...'
          # Use the robust heredoc syntax
          cat > fix_credentials.py <<-'EOF'
            import os
            import sys
            from urllib.parse import urlparse
            import psycopg2
            import traceback

            # Get current DB_URL
            db_url = os.environ.get('DB_URL', '')
            if not db_url:
              print(\"ERROR: DB_URL environment variable is not set\")
              sys.exit(1)
            
            # Mask password for printing
            sanitized_url = db_url
            try:
                parsed_for_print = urlparse(db_url)
                if parsed_for_print.password:
                    sanitized_url = db_url.replace(parsed_for_print.password, '***')
            except: pass # Ignore parsing errors for printing
            print(f'Current DB_URL (sanitized): {sanitized_url}')

            # Parse the URL
            try:
                parsed = urlparse(db_url)
                username = parsed.username
                password = parsed.password
                hostname = parsed.hostname
                port = parsed.port or 5432
                database = parsed.path.lstrip('/')
                
                if not all([username, password, hostname, database]):
                  print(\"ERROR: Could not parse all required components from DB_URL\")
                  sys.exit(1)

                # Try connection with original credentials
                print('\\nAttempting connection with current credentials...')
                try:
                    conn = psycopg2.connect(
                        dbname=database,
                        user=username,
                        password=password,
                        host=hostname,
                        port=port,
                        connect_timeout=10
                    )
                    print('SUCCESS! Connection worked with current credentials.')
                    conn.close()
                    sys.exit(0) # Exit successfully if this works
                except Exception as e:
                    print(f'ERROR: Connection failed: {str(e)}')
                    # Optional: print full traceback for detailed debugging
                    # traceback.print_exc()

            except Exception as e:
                print(f'Error parsing DB_URL or connecting: {str(e)}')
                traceback.print_exc()
                sys.exit(1)
          EOF
          
          # Run the script
          echo 'Running credential fix script...'
          # Ensure the backend service name is correct (e.g., 'backend')
          if docker compose exec -T backend python fix_credentials.py; then
             echo \"Credential check script ran successfully.\"
          else 
             echo \"Credential check script failed or connection error occurred. See script output above.\"
          fi
          # Clean up the script
          # rm fix_credentials.py 
        "
