name: Deploy Backend to EC2

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'  

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Configure SSH
      env:
        SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_KEY }}
      run: |
        mkdir -p ~/.ssh
        # Store the PEM key with proper formatting
        echo "$SSH_PRIVATE_KEY" > ~/.ssh/ec2-key.pem
        chmod 600 ~/.ssh/ec2-key.pem
        # Disable strict host key checking for deployment
        echo "Host *
          StrictHostKeyChecking no
          UserKnownHostsFile=/dev/null" > ~/.ssh/config
          
    - name: Get remote home directory
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      id: get_home
      run: |
        REMOTE_HOME=$(ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST 'echo $HOME')
        echo "REMOTE_HOME=$REMOTE_HOME" >> $GITHUB_ENV
        echo "Remote home directory: $REMOTE_HOME"

    - name: Create docker-compose.yml on Runner
      run: |
        cat > docker-compose.yml <<-'EOF'
          version: "3"
          services:
            backend:
              build: .
              restart: on-failure:5
              ports:
                - "8000:8000"
              env_file:
                - .env
              volumes:
                - ./backend:/app/backend
                - ./certs:/app/certs
              command: ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--ssl-keyfile", "/app/certs/key.pem", "--ssl-certfile", "/app/certs/cert.pem"]
        EOF

    - name: Create Dockerfile on Runner
      run: |
        cat > Dockerfile <<-'EOF'
          FROM python:3.13-slim
          WORKDIR /app
          RUN apt-get update && apt-get install -y --no-install-recommends build-essential gcc libcairo2-dev pkg-config && rm -rf /var/lib/apt/lists/*
          COPY backend/requirements.txt .
          RUN python -m pip install --upgrade pip
          RUN pip install --no-cache-dir -r requirements.txt
          COPY backend /app/backend
          WORKDIR /app/backend
          CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
        EOF

    - name: Sync Files to EC2
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      run: |
        # Create the main app directory
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "mkdir -p $REMOTE_HOME/app"
        
        # Sync backend directory, excluding __pycache__
        echo "Syncing backend directory..."
        rsync -avz --delete --exclude='__pycache__' -e "ssh -i ~/.ssh/ec2-key.pem" ./backend/ $EC2_USERNAME@$EC2_HOST:$REMOTE_HOME/app/backend/
        
        # Sync docker-compose.yml
        echo "Syncing docker-compose.yml..."
        rsync -avz -e "ssh -i ~/.ssh/ec2-key.pem" ./docker-compose.yml $EC2_USERNAME@$EC2_HOST:$REMOTE_HOME/app/
        
        # Sync Dockerfile
        echo "Syncing Dockerfile..."
        rsync -avz -e "ssh -i ~/.ssh/ec2-key.pem" ./Dockerfile $EC2_USERNAME@$EC2_HOST:$REMOTE_HOME/app/

    - name: Setup EC2 Environment
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      run: |
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "
          sudo apt-get update && sudo apt-get install -y rsync docker-ce docker-ce-cli containerd.io jq
          sudo systemctl start docker
          sudo systemctl enable docker
          sudo usermod -aG docker $EC2_USERNAME
          
          # Install Docker Compose v2 if needed
          if ! docker compose version &> /dev/null; then
            LATEST_COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | jq -r .tag_name)
            DOCKER_CONFIG="$HOME/.docker"
            sudo mkdir -p $DOCKER_CONFIG/cli-plugins
            sudo curl -SL "https://github.com/docker/compose/releases/download/$LATEST_COMPOSE_VERSION/docker-compose-linux-x86_64" -o $DOCKER_CONFIG/cli-plugins/docker-compose
            sudo chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
          fi
          
          # Generate SSL certs
          cd $REMOTE_HOME/app && mkdir -p certs && cd certs &&
          openssl req -x509 -newkey rsa:4096 -nodes -out cert.pem -keyout key.pem -days 365 -subj '/CN=localhost'
        "

    - name: Create .env file on EC2
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
        DB_URL: ${{ secrets.DB_URL }}
        SECRET_KEY: ${{ secrets.SECRET_KEY }}
        POSTMARK_TOKEN: ${{ secrets.POSTMARK_TOKEN }}
        FRONTEND_BASE_URL: ${{ secrets.FRONTEND_BASE_URL }}
        ENVIRONMENT: "production"
      run: |
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "
          cd $REMOTE_HOME/app &&
          echo "DB_URL=$DB_URL" > .env &&
          echo "SECRET_KEY=$SECRET_KEY" >> .env &&
          echo "POSTMARK_TOKEN=$POSTMARK_TOKEN" >> .env &&
          echo "FRONTEND_BASE_URL=$FRONTEND_BASE_URL" >> .env &&
          echo "ENV=$ENVIRONMENT" >> .env &&
          echo "CORS_ORIGINS=https://www.hpggrind.se" >> .env
        "

    - name: Start Docker Compose Services
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      run: |
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "
          cd $REMOTE_HOME/app &&
          docker compose down --remove-orphans || echo 'No existing containers to stop' &&
          docker compose up -d --build &&
          echo 'Waiting for container to stabilize...' &&
          sleep 30
        "

    - name: Check Container Status and Logs
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      run: |
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "
          cd $REMOTE_HOME/app &&
          echo 'Checking container status...' &&
          docker ps -a --filter name=backend &&
          CONTAINER_STATUS=$(docker ps -a --filter name=backend --format '{{.Status}}') &&
          if [[ $CONTAINER_STATUS == *"Restarting"* ]] || [[ $CONTAINER_STATUS != *"Up"* ]]; then
            echo 'Container is not running properly. Status: ' $CONTAINER_STATUS &&
            echo 'Checking logs:' &&
            docker logs $(docker ps -aq --filter name=backend) || echo 'Could not get logs.' ;
          else
            echo 'Container appears to be stable. Status: ' $CONTAINER_STATUS ;
          fi
        "

    - name: Create Verification Script on EC2
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      run: |
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "
          cd $REMOTE_HOME/app &&
          echo 'Creating database verification script...' &&
          cat > verify_db_init.py << EOF
import sys
import traceback
import os
from urllib.parse import urlparse
import socket
import time

print("Starting database verification...")

# Basic settings check
db_url = os.environ.get('DB_URL')
if not db_url:
    print("ERROR: DB_URL environment variable not set")
    sys.exit(1)

print("DB_URL is set ✓")

try:
    parsed = urlparse(db_url)
    hostname = parsed.hostname
    port = parsed.port or 5432
    if not hostname:
      print("ERROR: Could not parse hostname from DB_URL")
      sys.exit(1)

    # Network Check
    print(f"Testing network connection to {hostname}:{port}...")
    for i in range(3):
        try:
            sock = socket.create_connection((hostname, port), timeout=5)
            print("Network connection successful ✓")
            sock.close()
            network_ok = True
            break
        except Exception as net_e:
            print(f"Network attempt {i+1} failed: {str(net_e)}")
            network_ok = False
            time.sleep(2)
    if not network_ok:
      print("ERROR: Failed to establish network connection after retries.")
      sys.exit(1)

    # Defer detailed connection check to diagnostic/init scripts
    print("Basic settings and network check passed. Detailed check will follow.")
    sys.exit(0)

except Exception as e:
    print(f"ERROR during verification: {str(e)}")
    traceback.print_exc()
    sys.exit(1)
EOF
        "

    - name: Run Verification Script in Container
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      run: |
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "
          cd $REMOTE_HOME/app &&
          echo 'Copying verification script to container...' &&
          docker cp verify_db_init.py $(docker compose ps -q backend):/app/verify_db_init.py &&
          echo 'Executing verification script...' &&
          if docker compose exec -T backend python /app/verify_db_init.py; then
            echo '✅ Basic verification successful.' ;
          else
            echo '❌ Basic verification failed. Check logs above.' ;
            # Decide if workflow should fail here: exit 1;
          fi &&
          echo 'Cleaning up verification script...' &&
          rm verify_db_init.py &&
          docker compose exec -T backend rm /app/verify_db_init.py
        "

    - name: Run Database Diagnostics
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      run: |
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "
          cd $REMOTE_HOME/app &&
          echo 'Running detailed database diagnostics...' &&
          docker compose exec -T backend python -m db_diagnostic || echo 'Database diagnostics command failed to run.'
        "

    - name: Initialize Database
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
      run: |
        ssh -i ~/.ssh/ec2-key.pem $EC2_USERNAME@$EC2_HOST "
          cd $REMOTE_HOME/app &&
          echo 'Attempting database initialization...' &&
          if ! docker compose exec -T backend python -m init_db; then
            echo 'Initialization failed. Check diagnostics and container logs.' ;
          else
            echo '✅ Database initialization script completed.' ;
          fi
        "
